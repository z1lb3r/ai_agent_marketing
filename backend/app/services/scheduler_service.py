# backend/app/services/scheduler_service.py
import asyncio
import logging
from datetime import datetime, timezone

from ..core.database import supabase_client
from .client_monitoring_service import ClientMonitoringService

logger = logging.getLogger(__name__)

class SchedulerService:
    def __init__(self):
        self.monitoring_service = ClientMonitoringService()
        self.task = None
        self.running = False
        
    def start(self):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫"""
        try:
            if self.running:
                logger.warning("Scheduler already running")
                return
                
            logger.info("Starting scheduler with asyncio approach...")
            
            # –°–æ–∑–¥–∞–µ–º asyncio task –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
            self.task = asyncio.create_task(self._monitoring_loop())
            self.running = True
            
            logger.info("Scheduler started successfully")
            
        except Exception as e:
            logger.error(f"Error starting scheduler: {e}")
            raise
    
    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫"""
        try:
            if not self.running:
                return
                
            logger.info("Stopping scheduler...")
            self.running = False
            
            if self.task and not self.task.done():
                self.task.cancel()
                
            logger.info("Scheduler stopped")
            
        except Exception as e:
            logger.error(f"Error stopping scheduler: {e}")
    
    async def _monitoring_loop(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ (–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É)"""
        logger.info("üöÄ SCHEDULER: Monitoring loop started")
        
        while self.running:
            try:
                # –í—ã–ø–æ–ª–Ω—è–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
                await self._monitor_all_users()
                
                # –ñ–¥–µ–º 60 —Å–µ–∫—É–Ω–¥ –¥–æ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏
                await asyncio.sleep(60)
                
            except asyncio.CancelledError:
                logger.info("üì¥ SCHEDULER: Monitoring loop cancelled")
                break
            except Exception as e:
                logger.error(f"‚ùå SCHEDULER: Error in monitoring loop: {e}")
                # –ü—Ä–∏ –æ—à–∏–±–∫–µ –∂–¥–µ–º 30 —Å–µ–∫—É–Ω–¥ –∏ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
                await asyncio.sleep(30)
    
    async def _monitor_all_users(self):
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        try:
            logger.info("üîç SCHEDULER: Running scheduled client monitoring check")
            
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –∞–∫—Ç–∏–≤–Ω—ã–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º
            active_users = await self._get_active_monitoring_users()
            
            if not active_users:
                logger.warning("‚ùå SCHEDULER: No active monitoring users found")
                return
            
            logger.info(f"‚úÖ SCHEDULER: Found {len(active_users)} active monitoring users")
            
            for user_data in active_users:
                user_id = user_data['user_id']
                settings = user_data
                
                logger.info(f"üîç SCHEDULER: Checking monitoring for user {user_id}")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ—Ä–∞ –ª–∏ –∑–∞–ø—É—Å–∫–∞—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                should_run = self._should_run_monitoring(settings)
                logger.info(f"üéØ SCHEDULER: Should run monitoring for user {user_id}: {should_run}")
                
                if should_run:
                    logger.info(f"üöÄ SCHEDULER: Running monitoring for user {user_id}")
                    
                    # –ó–∞–ø—É—Å–∫–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
                    await self._run_monitoring_for_user(user_id, settings)
                else:
                    logger.info(f"‚è∞ SCHEDULER: Skipping monitoring for user {user_id} - too early")
                    
        except Exception as e:
            logger.error(f"‚ùå SCHEDULER: Error in scheduled monitoring: {e}")
            import traceback
            logger.error(f"‚ùå SCHEDULER: Traceback: {traceback.format_exc()}")
    
    async def _get_active_monitoring_users(self) -> list:
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –∞–∫—Ç–∏–≤–Ω—ã–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º"""
        try:
            logger.info("üìä SCHEDULER: Querying database for active monitoring users")
            result = supabase_client.table('monitoring_settings').select('*').eq('is_active', True).execute()
            
            users = result.data or []
            logger.info(f"üìä SCHEDULER: Retrieved {len(users)} active monitoring users from database")
            
            for user in users:
                chats_count = len(user.get('monitored_chats', []))
                interval = user.get('check_interval_minutes', 'N/A')
                logger.info(f"üë§ SCHEDULER: User {user['user_id']} - chats: {chats_count}, interval: {interval}min")
            
            return users
            
        except Exception as e:
            logger.error(f"‚ùå SCHEDULER: Error getting active monitoring users: {e}")
            return []
    
    def _should_run_monitoring(self, settings: dict) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω—É–∂–Ω–æ –ª–∏ –∑–∞–ø—É—Å–∫–∞—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            last_check = settings.get('last_monitoring_check')
            interval_minutes = settings.get('check_interval_minutes', 5)
            
            logger.info(f"‚è∞ SCHEDULER: Checking interval - last_check: {last_check}, interval: {interval_minutes}min")
            
            if not last_check:
                logger.info("‚è∞ SCHEDULER: No last check time, running monitoring")
                return True
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º—è —Å —É—á–µ—Ç–æ–º timezone
            try:
                # –ü–∞—Ä—Å–∏–º –≤—Ä–µ–º—è –∏–∑ –ë–î (–º–æ–∂–µ—Ç –±—ã—Ç—å —Å timezone)
                if isinstance(last_check, str):
                    # –£–±–∏—Ä–∞–µ–º Z –∏ –∑–∞–º–µ–Ω—è–µ–º –Ω–∞ +00:00 –µ—Å–ª–∏ –µ—Å—Ç—å
                    time_str = last_check.replace('Z', '+00:00')
                    last_check_time = datetime.fromisoformat(time_str)
                else:
                    last_check_time = last_check
                
                # –ü—Ä–∏–≤–æ–¥–∏–º –∫ UTC –µ—Å–ª–∏ –µ—Å—Ç—å timezone info
                if last_check_time.tzinfo is not None:
                    last_check_utc = last_check_time.astimezone(timezone.utc)
                else:
                    # –ï—Å–ª–∏ timezone –Ω–µ—Ç, —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —ç—Ç–æ UTC
                    last_check_utc = last_check_time.replace(tzinfo=timezone.utc)
                
                # –¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –≤ UTC
                now_utc = datetime.now(timezone.utc)
                
                # –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–Ω–∏—Ü—É –≤ –º–∏–Ω—É—Ç–∞—Ö
                time_diff_minutes = (now_utc - last_check_utc).total_seconds() / 60
                
                logger.info(f"‚è∞ SCHEDULER: Time difference: {time_diff_minutes:.1f} minutes (need {interval_minutes})")
                
                if time_diff_minutes >= interval_minutes:
                    logger.info("‚úÖ SCHEDULER: Interval elapsed, running monitoring")
                    return True
                else:
                    logger.info(f"‚è≥ SCHEDULER: Too early, need to wait {interval_minutes - time_diff_minutes:.1f} more minutes")
                    return False
                    
            except Exception as time_error:
                logger.warning(f"‚ö†Ô∏è SCHEDULER: Error parsing time, running monitoring anyway: {time_error}")
                return True
            
        except Exception as e:
            logger.error(f"‚ùå SCHEDULER: Error checking if should run monitoring: {e}")
            # –ü—Ä–∏ –æ—à–∏–±–∫–µ –≤—Å–µ —Ä–∞–≤–Ω–æ –∑–∞–ø—É—Å–∫–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
            return True
    
    async def _run_monitoring_for_user(self, user_id: int, settings: dict):
        """–ó–∞–ø—É—Å—Ç–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            logger.info(f"üöÄ SCHEDULER: Starting monitoring execution for user {user_id}")
            
            # –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ –Ω–∞—á–∞–ª–µ
            await self._update_last_check_time(user_id)
            
            # –ü–æ–ª—É—á–∞–µ–º —à–∞–±–ª–æ–Ω—ã –ø—Ä–æ–¥—É–∫—Ç–æ–≤
            templates = await self._get_user_templates(user_id)
            if not templates:
                logger.warning(f"‚ùå SCHEDULER: No active product templates found for user {user_id}")
                return
            
            logger.info(f"üìù SCHEDULER: Found {len(templates)} active templates for user {user_id}")
            
            # –ü–æ–ª—É—á–∞–µ–º —á–∞—Ç—ã –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
            monitored_chats = settings.get('monitored_chats', [])
            if not monitored_chats:
                logger.warning(f"‚ùå SCHEDULER: No monitored chats configured for user {user_id}")
                return
            
            logger.info(f"üí¨ SCHEDULER: Monitoring {len(monitored_chats)} chats for user {user_id}")
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–∏—Å–∫ –∏ –∞–Ω–∞–ª–∏–∑
            await self.monitoring_service._search_and_analyze(user_id, settings)
            
            logger.info(f"‚úÖ SCHEDULER: Monitoring execution completed for user {user_id}")
            
        except Exception as e:
            logger.error(f"‚ùå SCHEDULER: Error running monitoring for user {user_id}: {e}")
    
    async def _update_last_check_time(self, user_id: int):
        """–û–±–Ω–æ–≤–∏—Ç—å –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø—Ä–æ–≤–µ—Ä–∫–∏"""
        try:
            current_time = datetime.now(timezone.utc).isoformat()
            
            supabase_client.table('monitoring_settings').update({
                'last_monitoring_check': current_time
            }).eq('user_id', user_id).execute()
            
            logger.info(f"üïê SCHEDULER: Updated last check time for user {user_id} to {current_time}")
            
        except Exception as e:
            logger.error(f"‚ùå SCHEDULER: Error updating last check time for user {user_id}: {e}")
    
    async def _get_user_templates(self, user_id: int) -> list:
        """–ü–æ–ª—É—á–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ —à–∞–±–ª–æ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            result = supabase_client.table('product_templates').select('*').eq('user_id', user_id).eq('is_active', True).execute()
            
            templates = result.data or []
            logger.info(f"üìù SCHEDULER: Retrieved {len(templates)} active templates for user {user_id}")
            return templates
            
        except Exception as e:
            logger.error(f"‚ùå SCHEDULER: Error getting user templates for user {user_id}: {e}")
            return []

    @property
    def scheduler(self):
        """–°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å health check - —ç–º—É–ª–∏—Ä—É–µ–º APScheduler"""
        class FakeScheduler:
            def __init__(self, running):
                self.running = running
        
        return FakeScheduler(self.running)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
scheduler_service = SchedulerService()